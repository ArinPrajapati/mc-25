<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Midterm Interactive Study Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Energetic & Playful (Using Tailwind's Indigo as the primary vibrant color against a neutral Slate background) -->
    <!-- Application Structure Plan: The SPA is structured as a narrative learning path, ideal for midterm prep. It begins with 'Introduction' (the "what and why"), moves to 'Core Technologies' (the cryptographic "how"), then to 'Implementation' (the "build and operate"), and finishes with 'Network & Security' (the "environment and threats"). This thematic progression builds knowledge logically. A sticky navigation bar allows for both linear study and quick topic review. Interactivity is key: a live hash generator, a blockchain simulator, and comparison charts are designed to make abstract concepts tangible and improve retention. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Centralized vs. Decentralized -> Goal: Compare -> Viz/Presentation: Bar Chart -> Justification: Provides a quick, quantitative visual summary of key differences, making comparison intuitive. -> Library/Method: Chart.js (Canvas), adhering to NO SVG.
        - Report Info: Hashing -> Goal: Inform/Demonstrate -> Viz/Presentation: Live text-to-hash generator -> Justification: Offers hands-on experience with determinism and the avalanche effect, which is more effective than static text. -> Library/Method: Vanilla JS with Web Crypto API.
        - Report Info: Blockchain Structure -> Goal: Demonstrate/Change -> Viz/Presentation: Interactive chain of blocks -> Justification: Visually teaches immutability and the core principle of chained hashes by allowing users to see the chain break when data is tampered with. -> Library/Method: Vanilla JS DOM Manipulation.
        - Report Info: Merkle Tree -> Goal: Organize -> Viz/Presentation: Diagram built with HTML/CSS -> Justification: Clarifies how transactions are efficiently summarized into a single root hash using a clear visual hierarchy. -> Library/Method: HTML/CSS with Tailwind (NO SVG/Mermaid).
        - Report Info: P2P Network / Digital Signature -> Goal: Organize/Inform -> Viz/Presentation: Simple diagrams using styled HTML -> Justification: Breaks down complex processes into easy-to-digest steps without requiring heavy visualization. -> Library/Method: HTML/CSS with Tailwind (NO SVG).
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
        }
        .nav-link {
            transition: all 0.2s ease-in-out;
            border-bottom: 2px solid transparent;
        }
        .nav-link.active, .nav-link:hover {
            color: #4f46e5; /* indigo-600 */
            border-bottom-color: #4f46e5;
        }
        .content-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
            scroll-margin-top: 80px;
        }
        .interactive-block {
            border: 1px solid #e2e8f0; /* slate-200 */
            transition: all 0.3s ease-in-out;
        }
        .interactive-block.invalid {
            border-color: #ef4444; /* red-500 */
            background-color: #fee2e2; /* red-100 */
        }
        .merkle-node {
            border: 2px solid #64748b; /* slate-500 */
            padding: 0.5rem;
            border-radius: 0.375rem;
            text-align: center;
            font-family: monospace;
            font-size: 0.75rem;
            line-height: 1rem;
            word-break: break-all;
            position: relative;
        }
        .merkle-node .merkle-tooltip {
            visibility: hidden;
            width: 200px;
            background-color: #1e293b; /* slate-800 */
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            word-break: break-all;
        }
        .merkle-node:hover .merkle-tooltip {
            visibility: visible;
            opacity: 1;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
    </style>
</head>
<body class="bg-slate-50">

    <header class="bg-white/80 backdrop-blur-md shadow-sm sticky top-0 z-50">
        <nav class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <h1 class="text-xl font-bold text-indigo-600">Blockchain Study Guide</h1>
                <div class="hidden sm:flex sm:space-x-8">
                    <a href="#intro" class="nav-link text-gray-600 font-medium">Intro</a>
                    <a href="#core-tech" class="nav-link text-gray-600 font-medium">Core Tech</a>
                    <a href="#implementation" class="nav-link text-gray-600 font-medium">Implementation</a>
                    <a href="#network" class="nav-link text-gray-600 font-medium">Network & Security</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8">

        <section id="intro" class="content-card">
            <h2 class="text-2xl font-bold mb-4">What is Blockchain?</h2>
            <p class="mb-4">This section introduces the fundamental concepts of blockchain technology. We'll define what a blockchain is, explore its key features, and compare the centralized model we use today with the decentralized model that blockchain enables. Understanding this foundation is crucial before diving into the specific technologies that make it all work.</p>
            
            <h3 class="text-xl font-semibold mb-2">Definition & Structure</h3>
            <p class="mb-4">A blockchain is a distributed, immutable ledger. Think of it as a digital record book that's shared among many computers. It's structured as a chain of "blocks," where each block contains a list of transactions. Each block is cryptographically linked to the one before it, creating a secure and unbroken chain. This structure is what makes the ledger immutableâ€”changing a past record would require changing all subsequent blocks, which is computationally infeasible.</p>

            <div class="grid md:grid-cols-2 gap-8">
                <div>
                    <h3 class="text-xl font-semibold mb-2">Key Features of Blockchain</h3>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>Decentralization:</strong> No single entity has control. The ledger is maintained by a network of participants (nodes).</li>
                        <li><strong>Immutability:</strong> Once a transaction is recorded, it cannot be altered or deleted.</li>
                        <li><strong>Transparency:</strong> All participants on the network can see the transactions (though user identities can be pseudonymous).</li>
                        <li><strong>Security:</strong> Cryptography secures the network, linking blocks and verifying transactions.</li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2">Types of Blockchains</h3>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>Public:</strong> Anyone can join and participate (e.g., Bitcoin, Ethereum).</li>
                        <li><strong>Private:</strong> A single organization controls the network. Participants are invited.</li>
                        <li><strong>Consortium:</strong> A group of organizations governs the network.</li>
                    </ul>
                </div>
            </div>
            
            <hr class="my-8">
            
            <h3 class="text-xl font-semibold mb-4 text-center">Centralized vs. Decentralized Comparison</h3>
            <p class="text-center text-slate-600 mb-6">This chart visually compares key attributes of centralized and decentralized systems. Hover over the bars to see how they differ in terms of security, efficiency, and resistance to censorship.</p>
            <div class="chart-container">
                <canvas id="comparisonChart"></canvas>
            </div>
        </section>

        <section id="core-tech" class="content-card">
            <h2 class="text-2xl font-bold mb-4">Core Technologies</h2>
            <p class="mb-6">Here we explore the cryptographic building blocks that provide blockchain's security and integrity. You'll learn about hash functions, how they create a hash chain, how Merkle trees efficiently organize data, and how digital signatures prove ownership. These concepts are the bedrock of trust in a trustless system.</p>
            
            <h3 class="text-xl font-semibold mb-2">Hash & Hash Chain</h3>
            <p class="mb-4">A hash function is a mathematical algorithm that takes an input of any size and produces a fixed-size string of characters, known as a "hash." This process is one-way (you can't reverse it) and deterministic (the same input always produces the same output). A tiny change in the input will create a completely different output (the "avalanche effect"). A hash chain is the core of a blockchain, where each block contains the hash of the previous block, creating a secure, linked chain.</p>
            
            <div class="bg-slate-100 p-4 rounded-lg">
                <h4 class="font-semibold mb-2">Interactive Hash Generator (SHA-256)</h4>
                <p class="text-sm text-slate-600 mb-2">Type any data below to see its SHA-256 hash generated in real-time. Notice how even a small change dramatically alters the hash.</p>
                <textarea id="hashInput" class="w-full p-2 border border-slate-300 rounded-md" rows="3" placeholder="Type something here..."></textarea>
                <div class="mt-2">
                    <p class="font-semibold text-sm">Output Hash:</p>
                    <p id="hashOutput" class="text-sm font-mono break-all bg-white p-2 rounded-md">e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</p>
                </div>
            </div>
            
            <hr class="my-8">

            <h3 class="text-xl font-semibold mb-2">Merkle Tree</h3>
            <p class="mb-4">A Merkle Tree is a data structure used to efficiently verify the integrity of a large set of data. In blockchain, transactions in a block are hashed, then paired up and hashed again, continuing up the tree until a single hash remains: the Merkle Root. This root hash is stored in the block header. It allows for quick verification of a single transaction without needing to download and process the entire block.</p>
            
            <div class="p-4 bg-slate-100 rounded-lg">
                <h4 class="font-semibold mb-4 text-center">Simplified Merkle Tree Visualization</h4>
                <div class="flex flex-col items-center space-y-4">
                    <div class="merkle-node w-48 bg-indigo-100 border-indigo-500" data-hash="c216...3a4f">
                        Merkle Root
                        <span class="merkle-tooltip">Hash(H(AB) + H(CD)) = c216...3a4f</span>
                    </div>
                    <div class="w-px h-8 bg-slate-400"></div>
                    <div class="flex justify-center w-full gap-8 sm:gap-16">
                        <div class="merkle-node w-40 bg-blue-100 border-blue-500" data-hash="5d8f...e9c3">
                            Hash AB
                            <span class="merkle-tooltip">Hash(H(A) + H(B)) = 5d8f...e9c3</span>
                        </div>
                        <div class="merkle-node w-40 bg-blue-100 border-blue-500" data-hash="a1b2...f4d5">
                            Hash CD
                             <span class="merkle-tooltip">Hash(H(C) + H(D)) = a1b2...f4d5</span>
                        </div>
                    </div>
                    <div class="flex justify-center w-full gap-8 sm:gap-16">
                        <div class="w-px h-8 bg-slate-400"></div>
                        <div class="w-px h-8 bg-slate-400"></div>
                    </div>
                     <div class="flex justify-center w-full gap-2 sm:gap-4">
                        <div class="merkle-node w-20 sm:w-24 bg-teal-100 border-teal-500" data-hash="txA_hash">Tx A <span class="merkle-tooltip">Hash(Tx A Data)</span></div>
                        <div class="merkle-node w-20 sm:w-24 bg-teal-100 border-teal-500" data-hash="txB_hash">Tx B <span class="merkle-tooltip">Hash(Tx B Data)</span></div>
                        <div class="merkle-node w-20 sm:w-24 bg-teal-100 border-teal-500" data-hash="txC_hash">Tx C <span class="merkle-tooltip">Hash(Tx C Data)</span></div>
                        <div class="merkle-node w-20 sm:w-24 bg-teal-100 border-teal-500" data-hash="txD_hash">Tx D <span class="merkle-tooltip">Hash(Tx D Data)</span></div>
                    </div>
                </div>
            </div>

            <hr class="my-8">

            <h3 class="text-xl font-semibold mb-2">Digital Signature</h3>
            <p class="mb-4">A digital signature is a cryptographic mechanism used to verify the authenticity and integrity of a digital message or document. It uses public-key cryptography. A sender signs a message with their private key, and anyone can verify the signature using the sender's public key. In blockchain, you sign a transaction with your private key to prove you own the funds and authorize their transfer.</p>
            <div class="flex flex-col md:flex-row gap-4 text-center">
                <div class="flex-1 bg-slate-100 p-4 rounded-lg">
                    <h4 class="font-semibold mb-2">Signing Process</h4>
                    <p class="text-sm">Transaction Data + <strong class="text-red-600">Private Key</strong> â†’ Signed Transaction</p>
                </div>
                <div class="flex-1 bg-slate-100 p-4 rounded-lg">
                    <h4 class="font-semibold mb-2">Verification Process</h4>
                    <p class="text-sm">Signed Transaction + <strong class="text-green-600">Public Key</strong> â†’ Valid / Invalid</p>
                </div>
            </div>
        </section>

        <section id="implementation" class="content-card">
            <h2 class="text-2xl font-bold mb-4">Blockchain Implementation</h2>
             <p class="mb-6">This section provides a hands-on look at how a blockchain is built and operates. The interactive demo below lets you create blocks, add data, and link them together to form a chain. You can even try to tamper with the data in a previous block to see firsthand why a blockchain is considered immutable. We also briefly cover Bitcoin Script, the simple programming language used to define transaction conditions.</p>

            <h3 class="text-xl font-semibold mb-4 text-center">Interactive Blockchain Demo</h3>
            <div id="blockchain-demo" class="space-y-4">
            </div>
            <div class="mt-6 p-4 border-t border-slate-200">
                <h4 class="font-semibold mb-2">Add a New Block</h4>
                <div class="flex flex-col sm:flex-row gap-2">
                    <textarea id="blockData" class="flex-grow p-2 border border-slate-300 rounded-md" rows="2" placeholder="Enter transaction data for the new block..."></textarea>
                    <button id="addBlockBtn" class="bg-indigo-600 text-white font-semibold px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors">Add & Mine Block</button>
                </div>
            </div>
            
            <hr class="my-8">
            
            <h3 class="text-xl font-semibold mb-2">Bitcoin Script</h3>
            <p class="mb-4">Bitcoin Script is a simple, stack-based programming language used to process transactions. It's not a general-purpose language like Python or JavaScript; its capabilities are intentionally limited to avoid complex loops and vulnerabilities. The most common script type is Pay-to-Public-Key-Hash (P2PKH), which locks funds to a specific Bitcoin address. To spend the funds, the owner must provide a valid digital signature and their public key.</p>
        </section>

        <section id="network" class="content-card">
            <h2 class="text-2xl font-bold mb-4">Network & Security</h2>
            <p class="mb-6">A blockchain's security doesn't just come from cryptography; it also relies on its network architecture. Here, we discuss the peer-to-peer (P2P) network model that allows blockchains to be decentralized. We'll also examine a common threat to these networks, the Sybil Attack, and understand how blockchains like Bitcoin defend against it.</p>
            
            <h3 class="text-xl font-semibold mb-2">Peer-to-Peer (P2P) Network</h3>
            <p class="mb-4">Instead of a central server, blockchains operate on a peer-to-peer network. Each participant, or "node," holds a copy of the ledger and communicates directly with other nodes. When a new transaction or block is created, it's broadcast across the network. This distributed architecture removes single points of failure and makes the network resistant to censorship.</p>
            
            <div class="bg-slate-100 p-6 rounded-lg text-center">
                 <h4 class="font-semibold mb-2">P2P Network Structure</h4>
                 <div class="relative w-full h-48 flex items-center justify-center">
                    <div class="absolute w-12 h-12 bg-indigo-500 rounded-full text-white flex items-center justify-center text-xs font-bold" style="top: 0; left: 45%;">Node</div>
                    <div class="absolute w-12 h-12 bg-slate-700 rounded-full text-white flex items-center justify-center text-xs font-bold" style="top: 25%; left: 10%;">Node</div>
                    <div class="absolute w-12 h-12 bg-slate-700 rounded-full text-white flex items-center justify-center text-xs font-bold" style="top: 25%; right: 10%;">Node</div>
                    <div class="absolute w-12 h-12 bg-slate-700 rounded-full text-white flex items-center justify-center text-xs font-bold" style="bottom: 0; left: 25%;">Node</div>
                    <div class="absolute w-12 h-12 bg-slate-700 rounded-full text-white flex items-center justify-center text-xs font-bold" style="bottom: 0; right: 25%;">Node</div>
                    <p class="text-slate-600">All nodes communicate directly with peers</p>
                </div>
            </div>

            <hr class="my-8">

            <h3 class="text-xl font-semibold mb-2">Sybil Attack</h3>
            <p class="mb-4">A Sybil Attack is a security threat where an attacker creates a large number of pseudonymous identities (or "Sybils") to gain a disproportionately large influence in a network. In a P2P network, an attacker could create thousands of fake nodes to isolate a real node or disrupt the network. Public blockchains like Bitcoin mitigate this risk through Proof-of-Work. Since creating a block requires significant computational power (and cost), it becomes prohibitively expensive for an attacker to create enough Sybil nodes with sufficient mining power to take over the network.</p>
        </section>

    </main>

<script>
document.addEventListener('DOMContentLoaded', function() {
    
    const navLinks = document.querySelectorAll('.nav-link');
    const sections = document.querySelectorAll('main section');

    const observerOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0.3
    };

    const observer = new IntersectionObserver((entries, observer) => {
        let visibleSectionId = null;
        for (const entry of entries) {
            if (entry.isIntersecting) {
                visibleSectionId = entry.target.getAttribute('id');
                break;
            }
        }

        if (visibleSectionId) {
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${visibleSectionId}`) {
                    link.classList.add('active');
                }
            });
        }
    }, observerOptions);

    sections.forEach(section => {
        observer.observe(section);
    });

    async function calculateSHA256(str) {
        const textAsBuffer = new TextEncoder().encode(str);
        const hashBuffer = await crypto.subtle.digest('SHA-256', textAsBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hash;
    }

    const hashInput = document.getElementById('hashInput');
    const hashOutput = document.getElementById('hashOutput');
    hashInput.addEventListener('input', async () => {
        const inputVal = hashInput.value;
        if (inputVal === '') {
            hashOutput.textContent = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
        } else {
            hashOutput.textContent = await calculateSHA256(inputVal);
        }
    });

    const comparisonChartCtx = document.getElementById('comparisonChart').getContext('2d');
    new Chart(comparisonChartCtx, {
        type: 'bar',
        data: {
            labels: ['Security', 'Efficiency', 'Cost', 'Censorship Resistance', 'Transparency'],
            datasets: [
                {
                    label: 'Centralized',
                    data: [7, 9, 8, 3, 4],
                    backgroundColor: 'rgba(100, 116, 139, 0.6)', // slate-500
                    borderColor: 'rgba(100, 116, 139, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Decentralized',
                    data: [9, 5, 6, 9, 9],
                    backgroundColor: 'rgba(79, 70, 229, 0.6)', // indigo-600
                    borderColor: 'rgba(79, 70, 229, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 10,
                    title: { display: true, text: 'Score (1-10)' }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                         title: function(tooltipItems) {
                            const item = tooltipItems[0];
                            let label = item.chart.data.labels[item.dataIndex];
                            if (Array.isArray(label)) {
                              return label.join(' ');
                            } else {
                              return label;
                            }
                        }
                    }
                }
            }
        }
    });

    class Block {
        constructor(index, timestamp, data, previousHash = '') {
            this.index = index;
            this.timestamp = timestamp;
            this.data = data;
            this.previousHash = previousHash;
            this.hash = '';
            this.nonce = 0;
        }

        async calculateHash() {
            const dataToHash = this.index + this.previousHash + this.timestamp + this.data + this.nonce;
            return await calculateSHA256(dataToHash);
        }

        async mineBlock(difficulty) {
            this.hash = await this.calculateHash();
            while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join("0")) {
                this.nonce++;
                this.hash = await this.calculateHash();
            }
        }
    }

    class Blockchain {
        constructor() {
            this.chain = [];
            this.difficulty = 2;
        }

        async init() {
             if (this.chain.length === 0) {
                await this.createGenesisBlock();
             }
        }

        async createGenesisBlock() {
            const genesisBlock = new Block(0, Date.now(), "Genesis Block", "0");
            await genesisBlock.mineBlock(this.difficulty);
            this.chain.push(genesisBlock);
        }

        getLatestBlock() {
            return this.chain[this.chain.length - 1];
        }

        async addBlock(newBlock) {
            newBlock.previousHash = this.getLatestBlock().hash;
            await newBlock.mineBlock(this.difficulty);
            this.chain.push(newBlock);
        }
    }
    
    let studyChain = new Blockchain();
    const blockchainDemoContainer = document.getElementById('blockchain-demo');
    const blockDataInput = document.getElementById('blockData');
    const addBlockBtn = document.getElementById('addBlockBtn');
    
    async function renderBlockchain() {
        blockchainDemoContainer.innerHTML = '';
        let previousBlockHash = '0';
        
        for (let i = 0; i < studyChain.chain.length; i++) {
            const block = studyChain.chain[i];
            const blockEl = document.createElement('div');
            blockEl.classList.add('p-4', 'rounded-lg', 'shadow-md', 'interactive-block');
            blockEl.id = `block-${block.index}`;
            
            const currentHashRecalculated = await block.calculateHash();
            const isHashValid = block.hash === currentHashRecalculated;
            const isChainValid = block.previousHash === previousBlockHash;
            const isValid = isHashValid && isChainValid;
            
            if(!isValid) {
                 for(let j=i; j<studyChain.chain.length; j++){
                    const futureBlockEl = document.getElementById(`block-${j}`);
                    if(futureBlockEl) futureBlockEl.classList.add('invalid');
                 }
            }
            
            blockEl.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-bold text-lg">Block #${block.index}</h4>
                    <span class="text-xs font-mono px-2 py-1 rounded ${isValid ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">${isValid ? 'Valid' : 'Invalid'}</span>
                </div>
                <div class="space-y-2 text-sm">
                    <div><strong class="text-slate-500">Data:</strong> <textarea data-index="${block.index}" class="block-data-input w-full p-1 border rounded bg-slate-50 mt-1" ${block.index === 0 ? 'disabled' : ''}>${block.data}</textarea></div>
                    <div class="font-mono break-all"><strong class="font-sans text-slate-500">Hash:</strong> <span class="${isHashValid ? 'text-indigo-600' : 'text-red-600'}">${block.hash.substring(0, 30)}...</span></div>
                    <div class="font-mono break-all"><strong class="font-sans text-slate-500">Prev Hash:</strong> <span class="${isChainValid ? 'text-slate-600' : 'text-red-600'}">${block.previousHash.substring(0, 30)}...</span></div>
                    <div><strong class="text-slate-500">Nonce:</strong> ${block.nonce}</div>
                </div>
            `;
            blockchainDemoContainer.appendChild(blockEl);
            previousBlockHash = block.hash;
        }
        
        document.querySelectorAll('.block-data-input').forEach(input => {
            input.addEventListener('input', async (e) => {
                const index = parseInt(e.target.getAttribute('data-index'));
                studyChain.chain[index].data = e.target.value;
                await renderBlockchain();
            });
        });
    }
    
    addBlockBtn.addEventListener('click', async () => {
        addBlockBtn.disabled = true;
        addBlockBtn.textContent = 'Mining...';
        const data = blockDataInput.value || `Transaction Data ${studyChain.chain.length}`;
        const newBlock = new Block(studyChain.chain.length, Date.now(), data);
        await studyChain.addBlock(newBlock);
        await renderBlockchain();
        blockDataInput.value = '';
        addBlockBtn.disabled = false;
        addBlockBtn.textContent = 'Add & Mine Block';
    });

    studyChain.init().then(() => {
        renderBlockchain();
    });
});
</script>
</body>
</html>

